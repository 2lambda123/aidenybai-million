import Image from 'next/image';
import { VDomExample } from '../../components/examples/vdom';
import { StaticAnalysisExample } from '../../components/examples/static-analysis';
import { BlockVDomExample } from '../../components/examples/block-vdom';
import { CountExample } from '../../components/examples/count';
import { Callout } from 'nextra-theme-docs';

<a href="https://www.youtube.com/watch?v=2-fR2rrmw3I">
  <Image src="/back-in-block.png" width={300} height={130} />
</a>

# Virtual DOM: Back in Block

A comprehensive analysis on the current state of the virtual DOM, and what's to come next.

<Callout>
  **This is a deep dive — THIS IS NOT a beginner-friendly post.** If you're
  looking to learn Million.js, try the
  [quickstart](https://millionjs.org/docs/quickstart) instead.

This post is aimed at experienced programmers that want to deep dive into React and Million.js internals.

</Callout>

---

<small>[AIDEN BAI](https://aidenybai.com) MAY 1 2023</small>

<br />

A little over four years ago, Rich Harris released [Virtual DOM is pure overhead](https://svelte.dev/blog/virtual-dom-is-pure-overhead), analyzing the performance of traditional virtual DOM manipulation.<a href="#0"><sup>[0]</sup></a>

> <sup id="#0">[0]</sup> "you've probably heard the phrase 'the virtual DOM is fast',
> often said to mean that it's faster than the real DOM. It's a surprisingly resilient
> meme" – Harris, 2018

Rich's article was not a critique of the virtual DOM itself. Rather, it was a critique of the performance meme that the virtual DOM is faster than the DOM.

But what followed years after was the emergence of a new meme: that the virtual DOM **is pure overhead**. The meme became so resilient that it turned the "no virtual DOM" framework movement from an iconoclastic subgroup to a fully fledged crusade.

Thus, the virtual DOM was relegated to the "annoying cousin nobody likes but has to invite to family gatherings" status. It became necessary evil, a performance tax that we had to pay for the convenience of declarative UIs.

Until now.

## Origin story

Up until 2022, most frameworks thought of the virtual DOM as a tree of element nodes. These frameworks would then diff a "current" virtual DOM tree with a "new" virtual DOM tree, and apply the necessary changes to the real DOM.

Let's say we're given some React component `<Numbers />{:jsx}`:

```jsx
function Numbers() {
  return (
    <foo>
      <bar>
        <baz />
      </bar>
      <boo />
    </foo>
  );
}
```

<VDomExample />

In the previous example, you can see that diffing depends on the size of the tree, ultimately resulting in the bottleneck of the virtual DOM.

But in 2022, [Blockdom](https://github.com/ged-odoo/blockdom) was released–a major breakthrough in the virtual DOM space.

What did Blockdom do? They introduced the concept of the block virtual DOM.

## The Block Virtual DOM

Million.js takes a very similar approach to Blockdom. The Block virtual DOM takes a different approach to diffing, and can be broken down into two parts:

1. **Static Analysis**: The virtual DOM is analyzed to extract dynamic parts of the tree into a "Edit Mapping."

2. **Dirty Checking**: The state (**not** the virtual DOM tree) is diffed the to determine what has changed. If the state has changed, the DOM is updated directly via the "Edit Mapping."

If we take an example snippet code of Million.js inside React like this:

```jsx {7-8,13-14}
import { useState } from 'react';
import { block } from 'million/react';

function Count() {
  const [count, setCount] = useState(0);

  const node1 = count + 1;
  const node2 = count + 2;

  return (
    <div>
      <ul>
        <li>{node1}</li>
        <li>{node2}</li>
      </ul>
      <button
        onClick={() => {
          setCount(count + 1);
        }}
      >
        Increment Count
      </button>
    </div>
  );
}

const CountBlock = block(Count);
```

<CountExample />

### Static Analysis

The static analysis step can occur at compile time or the first thing at runtime, depending on whether you use Milllion.js' experimental compiler or not.

<StaticAnalysisExample />

We can essentially represent this as a block of elements:

### Dirty Checking

<BlockVDomExample />

## Is this technique effective?

**Yes.\***

## Closing Thoughts

The block virtual DOM introduces a new way of thinking about the virtual DOM. And while it's not a silver bullet (virtual DOM is still overhead), it's an interesting field that has a lot of exploring to do.

Ultimately, my goal with Million.js is to finish what Blockdom started: to advance the idea of the block virtual DOM and see what we can make out of it.

[Discuss on Twitter](https://mobile.twitter.com/search?q=https%3A%2F%2Fmillionjs.org%2Fblog%2Fvirtual-dom) | [Edit on GitHub](https://github.com/aidenybai/million/blob/main/website/pages/blog/virtual-dom.mdx)

### Acknowledgements

- [Seb Lorber](https://twitter.com/sebastienlorber) for suggesting this blog article
- [Jesse Pense](https://twitter.com/JessePence5) for article inspiration resources
- [Everyone](https://twitter.com/aidenybai/status/1651286922957062144) who commented on the thread for feedback
- [Rich Harris](https://twitter.com/Rich_Harris)'s "Virtual DOM is pure overhead"
- [Dan Abramov](https://twitter.com/dan_abramov)'s "React as a UI runtime"
- [Ryan Carniato](https://twitter.com/RyanCarniato)'s "Components are Pure Overhead"
- [Chung Wu](https://twitter.com/chungwu)'s "How React server components work: an in-depth guide"

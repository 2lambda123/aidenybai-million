import { Disclosures } from '../../components/home/faq';
import { Callout, Tab, Tabs } from 'nextra-theme-docs';
import Link from 'next/link';
import dynamic from 'next/dynamic';

export const Demo = dynamic(() =>
  import('../../components/demo').then((mod) => mod.Demo),
);

# Introduction

Million.js est un compilateur d'optimisation extrêmement rapide et léger qui rend les [composants](https://react.dev) jusqu'à [_**70% plus rapides**_](https://krausest.github.io/js-framework-benchmark/current.html).

**TL;DR:** Imaginez des composants [React](https://react.dev) fonctionnant à la vitesse du JavaScript brut.

## Pourquoi Million.js?

Pour comprendre pourquoi utiliser Million.js, nous devons comprendre comment React met à jour les interfaces. Lorsqu'un état ou des propriétés d'une application changent, React procède à une mise à jour en deux phases : le rendu et la réconciliation.

Pour illustrer cela, disons que ceci est notre composant `App`:

```jsx
function App() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

Dans ce composant `App`, lorsque je clique sur le bouton, l'état de la variable `count` sera mis à jour et la balise `<p>` sera actualisée pour refléter la nouvelle valeur. Décomposons cela en deux étapes.

### Le rendu

La première étape est le rendu. Le rendu est le processus de génération d'un aperçu du composant actuel. Vous pouvez l'imaginer comme simplement "Appeler" la fonction `App` et stocker la sortie dans une variable. Voici à quoi ressemblerait l'aperçu de la fonction `App`:

```jsx
const snapshot = App();

// snapshot =
<div>
  <p>Count: 1</p>
  <button onClick={increment}>Increment</button>
</div>;
```

### La réconciliation

Afin de mettre à jour l'interface pour refléter le nouvel état, React doit comparer l'aperçu précédent au nouvel aperçu (_appelé "diffing"_). Le réconciliateur de React parcourra chaque élément de l'aperçu précédent et le comparera avec le nouvel aperçu. Si l'élément est le même, il le sautera. Si l'élément est différent, il le mettra à jour.

- La balise `<div>` est la même, donc elle n'a pas besoin d'être mise à jour. ✅
  - La balise `<p>` est la même, donc elle n'a pas besoin d'être mise à jour. ✅
    - Le texte à l'intérieur de la balise `<p>` est différent, donc il doit être mis à jour. ⚠ ️
  - La balise `<button>` est la même, donc elle n'a pas besoin d'être mise à jour. ✅
    - La propriété `onClick` est la même, donc elle n'a pas besoin d'être mise à jour. ✅
    - Le texte à l'intérieur de la balise `<button>` est le même, donc il n'a pas besoin d'être mis à jour. ✅

_(total: 6 vérifications de différences)_

```diff
<div>
-  <p>Count: 0</p>
+  <p>Count: 1</p>
  <button onClick={increment}>Increment</button>
</div>
```

À partir d'ici, nous pouvons voir que la balise `<p>` doit être mise à jour. React mettra ensuite à jour le nœud DOM `<p>` pour refléter la nouvelle valeur.

```jsx
<p>.innerHTML = `Count: ${count}`;
```

### Comment Million.js rend cela plus rapide

React est lent.

Le problème avec la réconciliation de React est qu'elle devient **exponentiellement plus lente** à mesure que vous avez plus d'éléments JSX. Avec cette `App` simple, elle n'a besoin de différencier que quelques éléments. Dans une application React du monde réel, vous pouvez facilement avoir des centaines d'éléments, ce qui ralentit les mises à jour de l'interface.

Million.js résout cela en **sautant complètement l'étape de différenciation** et en mettant à jour directement le nœud DOM.

Voici un exemple conceptuel de fonctionnement du réconciliateur Million.js :

```jsx
function App() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);

  // generated by compiler
  if (count !== prevCount) {
    <p>.innerHTML = `Count: ${count}`;
  }

  <button>.onclick = increment;

  // ...
}
```

Remarquez comment lorsque la variable `count` est mis à jour, Million.js mettra à jour directement le nœud DOM. Million.js transforme la réconciliation de React de O(n^3) (temps cubique) à O(1) (temps constant).

> Quelle est sa vitesse ? [**→ Consultez les benchmarks**](https://krausest.github.io/js-framework-benchmark/current.html)

## Configuration

La CLI de Million.js installera automatiquement le package et configurera votre projet pour vous.

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']} storageKey="selected-manager">
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  npx million@latest
  ```
  </Tab>
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  pnpx million@latest
  ```
  </Tab>
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  yarn add million@latest
  ```
  </Tab>
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  bunx million@latest
  ```
  </Tab>
</Tabs>

<Callout type="info">
  Million.js est compatible avec React 16 et versions ultérieures. Si vous
  utilisez une version plus ancienne de React, vous devrez d'abord effectuer une
  mise à niveau.
</Callout>

C'est tout! Votre projet tourne maintenant sur Million.js 🎉

## Million.js vs. React

La démo suivante est complète et utilise [le rendu basé sur les clés](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)
pour montrer comment la performance de Million.js se compare à celle de React

<br />

<Demo />

## Des questions ?

Si vous avez des questions ou avez besoin d'assistance, n'hésitez pas à les poser sur [Discord](https://million.dev/chat) ou à soumettre un problème sur [GitHub](https://github.com/aidenybai/million).

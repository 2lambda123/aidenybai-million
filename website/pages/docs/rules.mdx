---
title: 'Rules Of Blocks'
description: 'How to use blocks in your projects the right way'
---

import { Callout, Tabs, Tab, Cards, Card } from 'nextra-theme-docs';



# Rules of Blocks

You are probably here because you got an error message.

There are three common reasons you might be seeing it:

1. You might be **breaking Rules of Blocks.**
2. You might have **forgot to use the compiler.**
3. You've entered **unsupported behavior.**

## Breaking Rules of Blocks

Components wrapped in the `block(){:jsx}` function are called Blocks in Million.js.

Blocks are a special type of component that use a special, more performant virtual DOM to render. As such, they follow certain rules

Don’t call Hooks inside loops, conditions, or nested functions. Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component:

- ✅ Call them at the top level in the body of a function component.
- ✅ Call them at the top level in the body of a custom Hook.

## Using the compiler

You should add the compiler to the bundler of your choice for your project, that's like your way of informing your project about Million.js.

Not adding the compiler for your bundler will cause incompatibility with `block(){:jsx}` in your project.

__It simply won't work!__ Exactly why you need to add the compiler to your bundler, like this:

<Tabs items={['Next.js', 'Astro', 'Gatsby', 'Vite', 'Webpack', 'Rollup', 'Rspack', 'Esbuild']} storageKey="selected-bundler-compiler">
  <Tab>
  <Callout>
    Next.js support is currently in beta. Please report any issues you encounter.
  </Callout>
  ```js filename="next.config.mjs"
  import million from 'million/compiler';

  /** @type {import('next').NextConfig} */
  const nextConfig = {
    reactStrictMode: true,
  };

  export default million.next(nextConfig);
  ```
  </Tab>
  <Tab>
  <Callout>
    Astro support is currently in beta. Please report any issues you encounter.
  </Callout>
  ```js filename="astro.config.mjs"
  import { defineConfig } from 'astro/config';
  import million from 'million/compiler';

  export default defineConfig({
    vite: {
      plugins: [million.vite()]
    }
  });
  ```
  </Tab>
  <Tab>
  <Callout>
    Gatsby support is currently in beta. Please report any issues you encounter.
  </Callout>
  ```js filename="gatsby-node.js"
  const million = require('million/compiler');

  exports.onCreateWebpackConfig = ({ actions }) => {
    actions.setWebpackConfig({
      plugins: [million.webpack()],
    })
  }
  ```
  </Tab>
  <Tab>
  ```js filename="vite.config.js"
  import million from 'million/compiler';
  import { defineConfig } from 'vite';

  export default defineConfig({
    plugins: [million.vite()],
  });
  ```
  </Tab>
  <Tab>
  ```js filename="webpack.config.js"
  import million from 'million/compiler';

  export default {
    plugins: [million.webpack()],
  };
  ```
  </Tab>
  <Tab>
  ```js filename="rollup.config.js"
  import million from 'million/compiler';

  export default {
    plugins: [million.rollup()],
  };
  ```
  </Tab>
  <Tab>
  ```js filename="rspack.config.js"
  // @ts-check
  const { default: million } = require('million/compiler');

  /** @type {import('@rspack/cli').Configuration} */
  module.exports = {
    plugins: [million.rspack()],
  };
  ```
  </Tab>
  <Tab>
  ```js filename="esbuild.config.js"
  import million from 'million/compiler';
  import { build } from 'esbuild';

  build({
    plugins: [million.esbuild()],
  });
  ```
  </Tab>
</Tabs>

If you've managed to do everything stated here so far; you're on the right track. Kudos to you!


## Deoptimizations

<Callout>This section highlights some of the possible errors you might encounter using blocks </Callout>

There are a number of things that could have caused you to encounter errors. 

__Here are some errors / warnings and how to resolve them__:

<Callout>Found unsupported argument for block. Make sure blocks consume the reference to a component function, not the direct declaration.</Callout>

   The above usually occurs when you have an actual JSX component like `<Component/>` passed into the `block()` function instead of a reference to the JSX element as in `Component`. 
   Like this:

```jsx
const wrongComponentBlock = block(<Component/>) {/*wrong! ❌*/}

const correctComponentBlock = block(Component)  {/*correct! ✅*/}
```

<br/>

<Callout>Array.map() will degrade performance. We recommend removing the block on the current component and using a `<For />` component instead</Callout>

   The above usually occurs when you have an array of items to be rendered on your UI from your component, but you're trying to wrap the entire component with `block()`. Its not allowed to use `array.map()` inside a block, but you should use 
   `<For/>` instead. 
   
   It also allows for optimized array rendering:

```jsx
import { For } from 'million/react';
  
// Do this instead 

function MyComponent() {
const [items, setItems] = useState([1, 2, 3]);
    
  return (
    <div>
      <For each={items}>
        {(item) => <div key={item}>{item}</div>}
      </For>
    </div>
  );
}
```

<br/>

<Callout>Conditional expressions will degrade performance. We recommend using deterministic returns instead</Callout>

   The above usually occurs when you have use conditions to return (`if` statements for example) instead of returning at the end as in every regular component

```jsx
function MyComponent() {
 const [count, setCount] = useState(initial.count);
  
  if (count > 10) {
   return <div>Too many clicks!</div>; // ❌ don't use conditionals
  }

  return (
   <div>
     Count is {count}
   </div>
 );
}

const MyComponentBlock = block(MyComponent) // ❌ ERROR
```

<br/>


<Callout>You cannot use multiple returns in blocks. There can only be one return statement at the end of the block.</Callout>

   As the above says, you cannot use multiple return in blocks. This is unsupported at the moment. This is how you should return when you create a `block()`. A more subtle case:

```jsx
function MyComponent({bool}){
    return <div>{bool && <span>true</span>}</div> 
}

const MyComponentBlock = block(MyComponent) // ❌ ERROR
```

<br/>


<Callout>Components will cause degraded performance. Ideally, you should use DOM elements instead</Callout>

    At the moment, not everything needs to be handled / can be handled by Million.js; hence, if it can handle it, it's left for React to take over.
  
<br/>

<Callout>Expected a block statement for the component function. Make sure you are using a function declaration or arrow function </Callout>

    At the moment, Million.js doesn't do well with one-liners, the error above refers to the fact that you should be doing this:

  ```jsx
   const MyComponent = () => { return <div></div> } // ✅ Correct

   // or this

   function MyComponent() {
    return <div></div> // ✅ Correct
   }
  ```

   You however cannot do this, because, it is not a block (as in a Javascript block)
   ```jsx
    const Test = () => <div></div>  
   ```

<br/>

<Callout>Spread attributes aren't supported.</Callout>

    As the above says, you might want to use the spread syntax (ES6 syntax) on props, though React allows it, there is no support for them yet in blocks.
    For example:

    ```jsx
    function MyWrongComponent({props}) {
     return (
        <div {...props}>Some Props have been used</div> // ❌ Wrong
        )
    }

    
    function MyCorrectComponent({props}) {
      return (
        <div name={props.name} style={props.styles}>Some Props have been used</div> // ✅ Correct
      )
    }
    ```
<br/>

<Callout>You can only use block() with a function declaration or arrow function</Callout>

   Well, leagacy React has it such that we can have classes be used to create components, however that is old syntax now, but, if you happen to be finding it hard to be getting the error above; it might be because you
   aren't using function-components. To resolve this, all you have to do is to __Use Functional Components__.

   

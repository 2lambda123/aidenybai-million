---
title: 'Quick Start'
description: 'Get started with Million.js'
---

import dynamic from 'next/dynamic';
import { Callout, Tabs, Tab, Cards, Card } from 'nextra-theme-docs';
import { Box } from '../../components/box';
export const Demo = dynamic(() =>
  import('../../components/demo').then((mod) => mod.Demo),
);

# Quick Start

Welcome to the Million.js documentation (_woop woop ðŸŽ‰ðŸ¤‘_). Let's learn how we can integrate Million.js into our React applications.

<Callout type="info">
**You will learn:**
- How to use `block(){:jsx}` to convert React components into blocks
- How to use `<For>{:jsx}` for efficiently rendering lists
- When to use `block(){:jsx}` and `<For>{:jsx}`
- The limitations of blocks
</Callout>

## What's a block?

Million.js is a library that enables you to create _blocks_. A block is a special [Higher Order Component (HOC)](https://legacy.reactjs.org/docs/higher-order-components.html) that can be used as a React component but are hyper-optimized for rendering speed.

Blocks are essentially components wrapped by `block(){:jsx}`.

```jsx {7}
function Dino() {
  return (
    <img src="https://millionjs.org/rubber-ducky-dino.png" />
  );
}

const DinoBlock = block(Dino);
```

Blocks can be used just like a normal React component:

```jsx {5}
export default function App() {
  return (
    <div>
      <h1>you promised me answers duck</h1>
      <DinoBlock />
    </div>
  );
}
```

Have a look at the result:

<Box previewOnly code={`
  import { block } from 'million/react';

  function Dino() {
    return (
      <img src="/rubber-ducky-dino.png" />
    );
  }

  const DinoBlock = block(Dino);

  export default function App() {
    return (
      <div>
        <h1>you promised me answers duck</h1>
        <DinoBlock />
      </div>
    );
  }
`} />

With that in hand, let's build an app.

## Data Grid Example

One use case of blocks is rendering lists of data efficiently. In this example, let's build a data grid in React.

We have access to the prebuilt components `<Table />{:jsx}` and `<Input />{:jsx}` from our user interface (UI) library. We can then store the number of rows we want to display in a `useState(){:jsx}` hook.

```jsx
function App() {
  const [rows, setRows] = useState(1);

  return (
    <div>
      <Input value={rows} setValue={setRows} />
      <Table>
        // ...
      </Table>
    </div>
  );
}
```

But wait! We made a grid but we have no data. Let's say we can grab some array of arbitrary data from a function called `buildData(rows){:jsx}`:

```jsx
const data = buildData(100);
// returns [{ adjective: '...', color: '...', noun: '...' }, ... x100]
```

Now, we can render the data in our table using `Array.map(){:jsx}`:

```jsx {3, 9-15}
function App() {
  const [rows, setRows] = useState(1);
  const data = buildData(rows);

  return (
    <div>
      <Input value={rows} setValue={setRows} />
      <Table>
        {data.map(({ adjective, color, noun }) => (
          <tr>
            <td>{adjective}</td>
            <td>{color}</td>
            <td>{noun}</td>
          </tr>
        ))}
      </Table>
    </div>
  );
}
```

<Box previewOnly code={`
  import { useState } from 'react';
  import { Table, Input } from './ui';
  import { buildData } from './data';

  function App() {
    const [rows, setRows] = useState(1);
    const data = buildData(rows);

    return (
      <div>
        <Input value={rows} setValue={setRows} />
        <Table>
          {data.map(({ adjective, color, noun }) => (
            <tr>
              <td>{adjective}</td>
              <td>{color}</td>
              <td>{noun}</td>
            </tr>
          ))}
        </Table>
      </div>
    );
}

export default App;
`} />

We can see that it performs pretty well. From 0-100, there's virtually no lag, but once you get higher than 500 or so, there's a noticable delay in rendering.

Cool right? React is great because we can declaratively write great UI and get pretty good performance. But the data grid we just made is a rudimentary example, and is not necessarily representative of most React applications.

### More realistic rendering

So, let's introduce some spice. In the following example, we add `lotsOfElements` (an array of a lot of blank elements) to each row. We also add a lag radar to monitor page performance.

Try changing the input value up and down from 0 to 1000. Notice how React _really struggles_ when rendering a lot of elements.

<Box code={`
  import { useState } from 'react';
  import { Table, Input, lotsOfElements } from './ui';
  import { buildData } from './data';

  function App() {
    const [rows, setRows] = useState(1);
    const data = buildData(rows);

    return (
      <div>
        <Input value={rows} setValue={setRows} />
        <Table showRadar>
          {data.map(({ adjective, color, noun }) => (
            <tr>
              <td>{adjective}</td>
              <td>{color}</td>
              <td>{noun}</td>
              <td>{...lotsOfElements}</td>
            </tr>
          ))}
        </Table>
      </div>
    );
}

export default App;
`} />

### Just `block` it

In the following example, we use `block(){:jsx}` and `<For />{:jsx}` in order to optimize rendering.

First, we need to abstract the `<tr>{:jsx}` into its own component.

```jsx
data.map(({ adjective, color, noun }) => (
  <tr>
    <td>{adjective}</td>
    <td>{color}</td>
    <td>{noun}</td>
    <td>{...lotsOfElements}</td>
  </tr>
))

// ðŸ‘‡ðŸ‘‡ðŸ‘‡

function Row({ adjective, color, noun }) {
  return (
    <tr>
      <td>{adjective}</td>
      <td>{color}</td>
      <td>{noun}</td>
      {...lotsOfElements}
    </tr>
  );
}
```

Then, we can wrap it with `block(){:jsx}` in order to optimize the `<Row />{:jsx}` component.

```jsx
const RowBlock = block(Row);
```

Once, we've optimized a row, we need to render it as a list:

```jsx
data.map(({ adjective, color, noun }) => (
  <RowBlock adjective={adjective} color={color} noun={noun}>
));
```

**BUT WAIT!** We can actually use Million.js' built-in rendering solution.

### Optimized List Rendering

The `<For />{:jsx}` component is used to render a list of blocks. It takes an array as the `each` prop and a function as its children. The function is called for each item in the array and is passed the item and its index as arguments.

<Callout type="info">
**`<For />{:jsx}` Component**

Syntax: `<For each={array}>{(item, index) => Block}</For>{:jsx}`\
Example: `<For each={[1, 2, 3]}>{(item, index) => myBlock({ item, index })}</For>{:jsx}`
</Callout>

It's the best way to loop over an array (uses [`mapArray(){:jsx}`](/map-array) under the hood). As the array changes, `<For />{:jsx}` updates or moves items in the DOM rather than recreating them. Let's look at an example:

With this in mind, we can rewrite our table to use `<For />{:jsx}`:

```jsx
<For each={data}>
  {({ adjective, color, noun }) => (
    <RowBlock adjective={adjective} color={color} noun={noun} />
  )}
</For>
```

Now that we've integrated Million.js, let's check the new example out.

Notice when you change the input value, the lag radar shows significantly less lag than the pure React example. With a [faster underlying virtual DOM](/blog/virtual-dom), Million.js can take a lot of the pain out of rendering large lists.

<Box code={`
  import { useState } from 'react';
  import { Table, Input, lotsOfElements } from './ui';
  import { buildData } from './data';
  import { block, For } from 'million/react';

  function Row({ adjective, color, noun }) {
    return (
      <tr>
        <td>{adjective}</td>
        <td>{color}</td>
        <td>{noun}</td>
        {...lotsOfElements}
      </tr>
    );
  }

  const RowBlock = block(Row);

  function App() {
    const [rows, setRows] = useState(1);
    const data = buildData(rows);

    return (
      <div>
        <Input value={rows} setValue={setRows} />
        <Table showRadar>
          <For each={data}>
            {({ adjective, color, noun }) => (
              <RowBlock adjective={adjective} color={color} noun={noun} />
            )}
          </For>
        </Table>
      </div>
    );
}

export default App;
`} />

### Million.js vs. React

<Callout type="info">
 The following is a more comprehensive demo using [key-based rendering](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) to show how Million.js performance compares to React.
</Callout>

<br />

<Demo />

## Hitting the limit

Blocks are great for rendering large lists, data grids, and many other use cases. However, you should always use best judgement, as blocks are not a silver bullet. Here are some general guidelines to follow:

- **Static views**: Blocks perform best when there's not that much dynamic data. Since static parts of the React tree need to be unnecessary rerendered when dynamic data changes by React, blocks can directly skip to what's dynamic.
- **Nested data**: Blocks are great for rendering nested data. Million.js turns tree traversal from `O(tree)` to `O(1)`, allowing for fast access and changes.

Looking for more strict guidelines? Check out [Rules of Blocks](/docs/rules).

## Next Steps

By now, you know the basics of how to integrate Million.js into your application!

Check out the the [installation guide](/docs/install) to put them into practice and start using blocks.



---

_This page is directly inspired by [React's Quick start page](https://react.dev/learn)._